name: Workflow 2 => Build Features Branches # Nombre del workflow

# Eventos que lo ejectutan este workflow
on:
  pull_request:
    branches: [ develop ] # El workflow se ejecuta cuando se detecta un evento 'Pull Request' en la rama 'develop'
    types: [ opened, reopened ] # El workflow se ejecuta cuando se abre o se reabre un Pull Request

jobs:
  job-1-workflow-2-build-features: # Nombre del job: 'build-features', este job se ejecuta cuando se detecta un evento 'Pull Request' en la rama 'develop'
                  # Este job se encarga de compilar el proyecto Java con Maven y subir los artefactos generados a GitHub Actions
    runs-on: ubuntu-latest # definimos el runner y/o la maquina virtual en donde se va a ejecutar este job, puede ser de ubuntu u 
                          # otra distribución de Linux, o incluso Windows o MacOS en la versión que se necesite

    #********************************* STEPS AND ACTIONS *********************************#

    # Ahora, debemos definir los pasos que se van a ejecutar en este job, en este caso, vamos a compilar un proyecto Java con Maven.

    # GitHub Actions nos ofrece múltiples posibilidades para configurar en los pasos y no son más que pequeñas aplicaciones que ha 
    # creado GitHub Actions y la comunidad y que incluso nosotros podríamos crear y publicar en un Market Place, y esta suite de 
    # GitHub Actions tiene acceso a todo lo que hay publicado en ese MarketPlace. La clave está en comprender cuáles son las que
    # nosotros tenemos que utilizar.

    # Por ejemplo, en los pasos, podemos definir cada una de las acciones que se van a ejecutar, por ejemplo, podemos
    # defirnie acciones predefinidas de GitHub Actions, como 'actions/checkout' para descargar el código del repositorio,
    # 'actions/setup-java' para configurar el JDK, 'actions/cache' para almacenar en caché las dependencias de Maven y 
    # 'actions/upload-artifact' para subir los artefactos  generados por la compilación y estas Actions, las podemos encontrar en
    # GitHub Marketplace.

    steps:
      - name: Pull and checkout from git repository # Nombre del paso que se va a ejecutar
        uses: actions/checkout@v4 # Esta Action descarga el codigo del repositorio para el runner y/o maquina virtual que definimos
                                  # anteriormente en la sección 'runs-on'
        with:
          ref: ${{ github.event.pull_request.head.sha }} # Esta línea asegura que se descargue el código del Pull Request específico que
                                                        #se está abriendo o reabriendo

      - name: Commads thers # Nombre del paso que se va a ejecutar
        run: |
          echo "Pulling and checking out the code from the repository"

      - name: Set up JDK with java 17 # Nombre del paso que se va a ejecutar
        uses: actions/setup-java@v4 # Esta Action configura el JDK que se va a utilizar en el runner y/o maquina virtual
        with:
          distribution: 'temurin' # Distribución del JDK que se va a utilizar, en este caso, se utiliza la distribución Temurin
          java-version: '17' # Versión del JDK que se va a utilizar, en este caso, la versión 17

      - name: Cache Maven dependencies # Nombre del paso que se va a ejecutar
        uses: actions/cache@v4 # Esta Action almacena en caché las dependencias de Maven para acelerar las compilaciones futuras
        with:
          path: ~/.m2/repository # Ruta donde se almacenan las dependencias de Maven
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }} # Clave para identificar la caché, se basa en el sistema operativo
                                                                    # y el hash de los archivos pom.xml
          # ${{ runner.os }}-maven-  es la clave de restauración para la caché, se utiliza si no se encuentra una coincidencia exacta.
          restore-keys: |
            ${{ runner.os }}-maven-
        
      - name: Build with Maven # Nombre del paso que se va a ejecutar
        run: |
          mvn clean test package # Este comando compila el proyecto, ejecuta las pruebas y empaqueta los artefactos necesarios, 
                                # en este caso, se utiliza Maven
          echo "Build with Maven completed successfully" # Mensaje que se muestra en la consola cuando la compilación se completa correctamente

  merge-feature-into-develop: # Nombre del job: 'merge-feature-into-develop', este job se ejecuta cuando se detecta un evento 'Pull Request' en la rama 'develop'
                              # Este job se encarga de fusionar el código del Pull Request en la rama 'develop' y subir los cambios al repositorio
    runs-on: ubuntu-latest # Definimos el runner y/o la maquina virtual en donde se va a ejecutar este job, puede ser de ubuntu u 
                              # otra distribución de Linux, o incluso Windows o MacOS en la versión que se necesite

    needs: build-features # Este job se ejecuta después de que el job 'build-features' se haya completado con éxito. Esto se logra mediante la propiedad 'needs',
                          # que indica que este job depende o necesita de la finalización exitosa del job 'build-features'
    if: ${{ success() }} # Este job se ejecuta solo si el job 'build-features' se ha completado con éxito. Esto se logra mediante la propiedad 'if',
                          # que evalúa si el job anterior fue exitoso
    # [For a specific job, you can use jobs.<job_id>.permissions to modify the default permissions granted to the 
    # GITHUB_TOKEN](https://docs.github.com/en/actions/using-jobs/assigning-permissions-to-jobs)
    permissions: # Definimos los permisos que se le van a otorgar al job, en este caso, se le otorgan permisos de lectura y escritura
                # a los repositorios, issues, pull requests y contenidos del repositorio
                # Estos permisos son necesarios para que el job pueda fusionar el código del Pull Request en la rama 'develop' y subir los
                # cambios al repositorio
      contents: write
      pull-requests: write
    
    steps:
      - name: Pull and checkout from git repository # Nombre del paso que se va a ejecutar
        uses: actions/checkout@v3 # Esta Action descarga el código del repositorio para el runner y/o maquina virtual que definimos
        with:
          #Dowload the code from destination branch (develop)
          ref: ${{ github.base_ref }} # Esta línea asegura que se descargue el código de la rama 'develop'
          fetch-depth: 0 # Esta línea asegura que se descargue todo el historial del repositorio, no solo el último commit

      - name: Merge to development branch # Nombre del paso que se va a ejecutar
        if: ${{ success() }} # Este paso se ejecuta solo si el job 'build-features' se ha completado con éxito
        run: |
          # Configura el correo electrónico del usuario que realiza la fusión
          git config --global user.email "EMAIL-OF-WORKFLOW@USER"

          # Configura el nombre del usuario que realiza la fusión
          git config --global user.name "WORKFLOW-USER"

          # Using -m "message" on merge command is mandatory here in order to avoid open a text editor to write a commit message
          git merge --no-ff --verbose origin/${{ github.event.pull_request.head.ref }} -m "Merge pull request #${{ github.event.number }}"

      - name: Push changes after merge # Nombre del paso que se va a ejecutar
        # Este paso se encarga de subir los cambios al repositorio después de la fusión
        if: ${{ success() }} # Este paso se ejecuta solo si el job 'build-features' se ha completado con éxito
        # Esta Action sube los cambios al repositorio, en este caso, se utiliza la Action 'ad-m/github-push-action'
        uses: ad-m/github-push-action@master 
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }} 
          branch: ${{ github.base_ref }} # Esta línea asegura que los cambios se suban a la rama 'develop'
